---
title: "DuckDB 存储引擎架构：现代列式数据库的设计与实现"
date: 2025-12-14T00:00:00+08:00
draft: false
tags: ["DuckDB", "存储引擎", "列式数据库", "数据库架构"]
categories: ["数据库", "系统架构"]
---

# DuckDB 存储引擎架构：现代列式数据库的设计与实现

在数据处理领域，存储引擎的设计对数据库性能有着决定性影响。DuckDB作为一款专为分析工作负载优化的嵌入式数据库，其存储引擎展现了现代列式数据库设计的精髓。通过深入探索源码，我们可以一窥其背后精妙的架构设计。

## 1. 整体架构层次

DuckDB存储引擎采用分层设计，顶层管理组件协调各个子系统：

```
┌─────────────────────────────────────────────────────────┐
│                    StorageManager                       │
│                    (Top Level)                          │
├─────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌──────────────────────────────┐  │
│  │   BlockManager  │  │       BufferManager        │  │
│  │ (Block Mgmt)    │  │     (Buffer Pool)          │  │
│  └─────────────────┘  └──────────────────────────────┘  │
│           │                        │                    │
│           ▼                        ▼                    │
│  ┌─────────────────┐  ┌──────────────────────────────┐  │
│  │ WriteAheadLog   │  │    CheckpointManager       │  │
│  │     (WAL)       │  │   (Consistency & Backup)   │  │
│  └─────────────────┘  └──────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

整个存储系统的顶层由`StorageManager`统管，它负责协调底层的块管理、缓冲管理和事务日志系统。这种分层设计使得每个组件可以独立优化，同时保持良好的可维护性。

## 2. 数据组织模型

DuckDB采用行组（RowGroup）+ 列存储的混合架构，这是其性能优化的关键：

```
┌─────────────────────────────────────────────────────────┐
│                    DataTable (Table)                    │
├─────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────┐ │
│  │        RowGroupCollection (Row Group Collection)    │ │
│  ├─────────────────────────────────────────────────────┤ │
│  │  ┌─────────────────────────────────────────────────┐ │ │
│  │  │             RowGroup (1024-8192 rows)           │ │ │
│  │  ├─────────────────────────────────────────────────┤ │ │
│  │  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ │ │ │
│  │  │  │ Column  │ │ Column  │ │ Column  │ │ Column  │ │ │ │
│  │  │  │   A     │ │   B     │ │   C     │ │   D     │ │ │ │
│  │  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘ │ │ │
│  │  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ │ │ │
│  │  │  │Segment  │ │Segment  │ │Segment  │ │Segment  │ │ │ │
│  │  │  │ (blk1)  │ │ (blk2)  │ │ (blk3)  │ │ (blk4)  │ │ │ │
│  │  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘ │ │ │
│  │  └─────────────────────────────────────────────────┘ │ │
│  │  ┌─────────────────────────────────────────────────┐ │ │
│  │  │             RowGroup (next group)               │ │ │
│  │  └─────────────────────────────────────────────────┘ │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

这种设计巧妙地结合了行存储和列存储的优势：
- **行组（RowGroup）**：将表水平分割成多个块，每个块包含固定数量的行（通常是1024-8192行）
- **列段（ColumnSegment）**：每列在行组内的存储单元，支持多种压缩算法

这种分层结构使DuckDB能够：
- 按需加载特定列，提高I/O效率
- 对每列应用最适合的压缩算法
- 利用向量化执行引擎处理连续数据块

## 3. 核心组件详解

| Component | File | Responsibility |
|-----------|------|----------------|
| StorageManager | src/storage/storage_manager.cpp | Top-level storage management |
| BlockManager | src/storage/single_file_block_manager.cpp | Disk block allocation and I/O |
| BufferManager | src/storage/standard_buffer_manager.cpp | Memory buffer pool management |
| DataTable | src/storage/table/data_table.cpp | Table data management |
| RowGroup | src/storage/table/row_group.cpp | Row group management |
| ColumnData | src/storage/table/column_data.cpp | Column data management |

### 3.1 StorageManager：协调中心

`StorageManager`作为存储引擎的中枢，负责协调所有存储相关操作。它管理数据库文件的生命周期，协调WAL、检查点、缓冲池等组件的工作，确保数据一致性和性能优化。

### 3.2 BlockManager：物理存储抽象

`BlockManager`提供了物理存储的抽象层，将数据库的逻辑存储结构映射到物理文件。它负责：
- 固定大小块的分配和回收
- 块ID到文件偏移的映射
- 多线程安全的块访问

### 3.3 BufferManager：内存管理

缓冲管理器采用LRU（最近最少使用）策略管理内存池：

```
┌─────────────────────────────────────────────────────────┐
│              Buffer Management System                   │
├─────────────────────────────────────────────────────────┤
│  ┌─────────────────┐ ┌──────────────────────────────┐   │
│  │   BlockHandle   │ │     BufferHandle (RAII)    │   │
│  │ (Memory Handle) │ │   (Pin/Unpin Management)   │   │
│  │ - Load/Unload   │ │ - Automatic Pin/Unpin      │   │
│  │ - State Mgmt    │ │ - Lifetime Management      │   │
│  └─────────────────┘ └──────────────────────────────┘   │
│           │                        │                    │
│           ▼                        ▼                    │
│  ┌─────────────────────────────────────────────────────┐ │
│  │              Buffer Pool (LRU Strategy)             │ │
│  ├─────────────────────────────────────────────────────┤ │
│  │ Block A │ Block B │ Block C │ Block D │ ...       │ │
│  │ (Recent)              (Least Recently Used)        │ │
│  └─────────────────────────────────────────────────────┘ │
│           │                        │                    │
│           ▼                        ▼                    │
│  ┌─────────────────┐  ┌──────────────────────────────┐   │
│  │  EvictionQueue  │  │   Temp File Storage        │   │
│  │(Memory Pressure)│  │(Inactive Blocks Storage)   │   │
│  └─────────────────┘  └──────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

## 4. 事务与MVCC

DuckDB实现了完善的多版本并发控制（MVCC）机制：

```
┌─────────────────────────────────────────────────────────┐
│              MVCC Implementation                        │
├─────────────────────────────────────────────────────────┤
│  ┌─────────────────┐ ┌──────────────────────────────┐   │
│  │  LocalStorage   │ │    RowVersionManager       │   │
│  │ (Txn Local Mods)│ │ (Row-level Version Mgmt)   │   │
│  │ - Txn-specific  │ │ - Version Chains           │   │
│  │ - No blocking   │ │ - Visibility Control       │   │
│  └─────────────────┘ └──────────────────────────────┘   │
│           │                        │                    │
│           ▼                        ▼                    │
│  ┌─────────────────────────────────────────────────────┐ │
│  │              Transaction Isolation                  │ │
│  ├─────────────────────────────────────────────────────┤ │
│  │ Visibility Check: start_time vs commit_id         │ │
│  │ (Ensure ACID properties with concurrent access)    │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

MVCC实现的关键特性：
- **本地存储**：每个事务在提交前维护本地修改，避免阻塞其他事务
- **版本管理**：通过版本链管理数据的多个版本
- **时间戳控制**：使用事务开始时间和提交ID判断数据可见性

## 5. 检查点与WAL机制

DuckDB的持久化机制采用WAL（预写日志）+ 定期检查点的组合：

```
┌─────────────────────────────────────────────────────────┐
│                WAL + Checkpoint Process                 │
├─────────────────────────────────────────────────────────┤
│  Transaction Commit                                     │
│         │                                               │
│         ▼                                               │
│  ┌─────────────────┐                                   │
│  │   WAL Write     │ ← All changes write to log first │
│  │  (Durability)   │                                   │
│  └─────────────────┘                                   │
│         │                                               │
│         ▼                                               │
│  ┌─────────────────┐                                   │
│  │  Auto Checkpoint│ ← Triggered automatically        │
│  │    (Periodic)   │                                   │
│  └─────────────────┘                                   │
│         │                                               │
│         ▼                                               │
│  ┌─────────────────────────────────────────────────────┤
│  │      Checkpoint Contents:                           │
│  │  • Write Row Group Data                             │
│  │  • Write Metadata                                   │
│  │  • Cleanup WAL Records                              │
│  └─────────────────────────────────────────────────────┘
└─────────────────────────────────────────────────────────┘
```

### 5.1 WAL（预写日志）

WAL确保事务的持久性：
- 所有修改必须先写入日志
- 日志记录包含足够的信息用于恢复
- 支持崩溃恢复和故障转移

### 5.2 检查点

定期检查点机制：
- 将内存中的脏页刷新到磁盘
- 压缩存储格式，提高空间利用率
- 清理过期的WAL记录

## 6. 压缩算法支持

DuckDB在`src/storage/compression/`目录下实现了多种压缩算法：

```
┌─────────────────────────────────────────────────────────┐
│              Compression Algorithms Tree                │
├─────────────────────────────────────────────────────────┤
│  ┌─────────────────┐ ┌──────────────────────────────┐   │
│  │ Dictionary/FSST │ │        Bitpacking          │   │
│  │ (String cols)   │ │    (Integer cols)          │   │
│  └─────────────────┘ └──────────────────────────────┘   │
│           │                        │                    │
│           ▼                        ▼                    │
│  ┌─────────────────┐ ┌──────────────────────────────┐   │
│  │   ALP/ALPRD     │ │      Chimp/Patas           │   │
│  │ (Numeric cols)  │ │ (Floating-point cols)      │   │
│  └─────────────────┘ └──────────────────────────────┘   │
│           │                        │                    │
│           ▼                        ▼                    │
│  ┌─────────────────┐  ┌─────────────────────────────┐   │
│  │    Roaring      │  │   Auto Selection Logic    │   │
│  │ (Bitmap comp.)  │  │ (Based on data charact.)  │   │
│  └─────────────────┘  └─────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### 6.1 智能压缩选择

系统会根据数据特征自动选择最优压缩方式：

```
┌─────────────────────────────────────────────────────────┐
│            Automatic Compression Selection              │
├─────────────────────────────────────────────────────────┤
│  Column Type          →    Compression Algorithm       │
│  ─────────────────────────────────────────────────────  │
│  String/Text Columns   →   Dictionary/FSST             │
│  Integer Columns       →   Bitpacking/ALP              │
│  Floating Point Cols   →   Chimp/Patas                 │
│  Boolean/Flag Cols     →   Roaring Bitmap              │
│  ─────────────────────────────────────────────────────  │
│  ┌─────────────────────────────────────────────────────┐ │
│  │   Data Analysis Engine                              │ │
│  │   (Analyzes data characteristics)                   │ │
│  │   ↓                                                 │ │
│  │   Optimal Algorithm Selection                       │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 6.2 压缩优势

- **空间效率**：显著减少存储空间需求
- **I/O性能**：减少磁盘I/O，因为需要读取的数据量更少
- **CPU效率**：压缩数据传输和解压缩通常比处理未压缩数据更快

## 7. 性能优化特性

### 7.1 向量化执行配合

```
┌─────────────────────────────────────────────────────────┐
│            Vectorized Execution + Columnar Storage       │
├─────────────────────────────────────────────────────────┤
│  ┌─────────────────┐ ┌──────────────────────────────┐   │
│  │ Columnar Storage│ │    Vectorized Operators    │   │
│  │ (Contiguous     │ │    (Process blocks at once)│   │
│  │  data blocks)   │ │                            │   │
│  └─────────────────┘ └──────────────────────────────┘   │
│           │                        │                    │
│           ▼                        ▼                    │
│  ┌─────────────────────────────────────────────────────┐ │
│  │              High CPU Utilization                   │ │
│  │   (Process 1000s of rows per operation)             │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

列式存储与DuckDB的向量化执行引擎完美配合，每个操作符可以一次性处理一整块数据，最大化CPU利用率。

### 7.2 Zone Map（区域图）

```
┌─────────────────────────────────────────────────────────┐
│                    Zone Map Structure                   │
├─────────────────────────────────────────────────────────┤
│  Data Block A:                                        │
│  ┌─────────────────────────────────────────────────────┤
│  │  Min Value: 100    │  Max Value: 500              │
│  │  Null Count: 0     │  Stats: Count, Sum, etc.     │
│  └─────────────────────────────────────────────────────┤
│  Data Block B:                                        │
│  ┌─────────────────────────────────────────────────────┤
│  │  Min Value: 600    │  Max Value: 1000             │
│  │  Null Count: 2     │  Stats: Count, Sum, etc.     │
│  └─────────────────────────────────────────────────────┤
│                                                         │
│  Query: SELECT * FROM table WHERE value < 300          │
│  Result: Only scan Block A (Block B can be skipped)    │
└─────────────────────────────────────────────────────────┘
```

DuckDB使用Zone Map进行块级过滤，每个数据块都维护最小/最大值等统计信息，查询时可以快速跳过不相关的数据块。

### 7.3 零拷贝设计

通过精心设计的数据布局和内存管理，DuckDB尽量减少数据复制，提高处理效率。

## 8. 设计哲学与创新

DuckDB存储引擎的设计体现了几个重要理念：

1. **单文件存储**：整个数据库存储在单个文件中，简化部署和管理
2. **分析优化**：针对OLAP工作负载优化，而非OLTP事务处理
3. **自适应压缩**：根据数据特征自动选择最优压缩算法
4. **内存效率**：智能的缓冲管理和数据结构设计

## 9. 架构优势

### 9.1 性能优势

- 列式存储支持高效的分析查询
- 压缩技术减少I/O和内存使用
- 向量化执行最大化CPU利用率

### 9.2 易用性优势

- 嵌入式架构，无需独立服务进程
- 单文件存储，便于数据传输和备份
- 自动优化，无需复杂配置

## 10. 总结

DuckDB的存储引擎架构体现了现代分析数据库设计的精髓。通过列式存储、智能压缩、MVCC事务、向量化执行等技术的有机结合，DuckDB在保持架构简洁的同时实现了卓越的性能。

整个存储子系统约140个头文件，核心实现超过11,700行代码，展现了精心设计和工程实践的完美结合。对于数据库系统设计者和研究者而言，DuckDB的存储引擎提供了一个优秀的参考实现，展示了如何在有限的复杂度下实现高性能的分析型数据库存储系统。

从DuckDB的存储架构中，我们可以看到未来数据库系统发展的几个重要趋势：专业化、自适应性、以及对分析工作负载的深度优化。这些设计理念不仅适用于嵌入式数据库，也为大型分布式系统的存储设计提供了宝贵启示。